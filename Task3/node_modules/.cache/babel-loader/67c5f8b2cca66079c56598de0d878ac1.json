{"ast":null,"code":"import _classCallCheck from \"/Users/soham/Desktop/JPMC/JPMC-tech-task-3-PY3/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/soham/Desktop/JPMC/JPMC-tech-task-3-PY3/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/* \n● This change is necessary because it will be the structure of the return object of\n  the only function of the DataManipulator class, i.e. the generateRow function\n● It’s important that the return object corresponds to the the schema of the table\n  we’ll be updating in the Graph component because that’s the only way that we’ll\n  be able to display the right output we want. \n● Finally, we have to update the generateRow function of the DataManipulator\n  class to properly process the raw server data passed to it so that it can return\n  the processed data which will be rendered by the Graph component’s table.\n● Here we can compute for price_abc and price_def properly (like what you did\n  back in task 1). Afterwards we can also compute for ratio using the two\n  computed prices, (like what you did in task 1 too). And, set lower and upper\n  bounds, as well as trigger_alert. To better understand this see the expected\n  change in the next slide\n*/\nexport var DataManipulator =\n/*#__PURE__*/\nfunction () {\n  function DataManipulator() {\n    _classCallCheck(this, DataManipulator);\n  }\n\n  _createClass(DataManipulator, null, [{\n    key: \"generateRow\",\n    value: function generateRow(serverResponds) {\n      var priceABC = (serverResponds[0].top_ask.price + serverResponds[0].top_bid.price) / 2;\n      var priceDEF = (serverResponds[1].top_ask.price + serverResponds[1].top_bid.price) / 2;\n      var ratio = priceABC / priceDEF;\n      var upper_bound = 1 + 0.07;\n      var lower_bound = 1 - 0.07;\n      return {\n        price_abc: priceABC,\n        price_def: priceDEF,\n        ratio: ratio,\n        timestamp: serverResponds[0].timestamp > serverResponds[1].timestamp ? serverResponds[0].timestamp : serverResponds[1].timestamp,\n        upper_bound: upper_bound,\n        lower_bound: lower_bound,\n        trigger_alert: ratio > upper_bound || ratio < lower_bound ? ratio : undefined\n      };\n    }\n  }]);\n\n  return DataManipulator;\n}();\n/*\n● Observe how we’re able to access serverRespond as an array where in the\n  first element (0-index) is about stock ABC and the second element (1-index) is\n  about stock DEF. With this, we were able to easily just plug in values to the\n  formulas we used back in task 1 to compute for prices and ratio properly\n● Also note how the return value is changed from an array of Row objects to just\n  a single Row object This change explains why we also adjusted the argument\n  we passed to table.update in Graph.tsx earlier so that consistency is\n  preserved.\n● The upper_bound and lower_bound are pretty much constant for any data\n  point. This is how we will be able to maintain them as steady upper and lower\n  lines in the graph. While 1.05 and 0.95 isn’t really +/-10% of the 12 month\n  historical average ratio (i.e. 1.1 and 0.99) you’re free to play around with the\n  values and see which has a more conservative alerting behavior.\n● The trigger_alert field is pretty much just a field that has a value (e.g. the ratio)\n  if the threshold is passed by the ratio. Otherwise if the ratio remains within the\n  threshold, then no value/undefined will suffice.\n*/","map":{"version":3,"sources":["/Users/soham/Desktop/JPMC/JPMC-tech-task-3-PY3/src/DataManipulator.ts"],"names":["DataManipulator","serverResponds","priceABC","top_ask","price","top_bid","priceDEF","ratio","upper_bound","lower_bound","price_abc","price_def","timestamp","trigger_alert","undefined"],"mappings":";;;AAYA;;;;;;;;;;;;;;;AAiBA,WAAaA,eAAb;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,gCACqBC,cADrB,EAC2D;AACnD,UAAMC,QAAQ,GAAG,CAACD,cAAc,CAAC,CAAD,CAAd,CAAkBE,OAAlB,CAA0BC,KAA1B,GAAkCH,cAAc,CAAC,CAAD,CAAd,CAAkBI,OAAlB,CAA0BD,KAA7D,IAAoE,CAArF;AACA,UAAME,QAAQ,GAAG,CAACL,cAAc,CAAC,CAAD,CAAd,CAAkBE,OAAlB,CAA0BC,KAA1B,GAAkCH,cAAc,CAAC,CAAD,CAAd,CAAkBI,OAAlB,CAA0BD,KAA7D,IAAoE,CAArF;AACA,UAAMG,KAAK,GAAGL,QAAQ,GAAGI,QAAzB;AACA,UAAME,WAAW,GAAG,IAAI,IAAxB;AACA,UAAMC,WAAW,GAAG,IAAI,IAAxB;AACA,aAAO;AACLC,QAAAA,SAAS,EAAER,QADN;AAELS,QAAAA,SAAS,EAAEL,QAFN;AAGLC,QAAAA,KAAK,EAALA,KAHK;AAILK,QAAAA,SAAS,EAAEX,cAAc,CAAC,CAAD,CAAd,CAAkBW,SAAlB,GAA8BX,cAAc,CAAC,CAAD,CAAd,CAAkBW,SAAhD,GACTX,cAAc,CAAC,CAAD,CAAd,CAAkBW,SADT,GACqBX,cAAc,CAAC,CAAD,CAAd,CAAkBW,SAL7C;AAMLJ,QAAAA,WAAW,EAAEA,WANR;AAOLC,QAAAA,WAAW,EAAEA,WAPR;AAQLI,QAAAA,aAAa,EAAGN,KAAK,GAAGC,WAAR,IAAuBD,KAAK,GAAGE,WAAhC,GAAgDF,KAAhD,GAAwDO;AARlE,OAAP;AAUH;AAjBL;;AAAA;AAAA;AAqBA","sourcesContent":["import { ServerRespond } from './DataStreamer';\n\nexport interface Row {\n      price_abc: number,\n      price_def: number,\n      ratio: number,\n      lower_bound: number,\n      upper_bound: number,\n      trigger_alert: number | undefined,\n      timestamp: Date\n}\n\n/* \n● This change is necessary because it will be the structure of the return object of\n  the only function of the DataManipulator class, i.e. the generateRow function\n● It’s important that the return object corresponds to the the schema of the table\n  we’ll be updating in the Graph component because that’s the only way that we’ll\n  be able to display the right output we want. \n● Finally, we have to update the generateRow function of the DataManipulator\n  class to properly process the raw server data passed to it so that it can return\n  the processed data which will be rendered by the Graph component’s table.\n● Here we can compute for price_abc and price_def properly (like what you did\n  back in task 1). Afterwards we can also compute for ratio using the two\n  computed prices, (like what you did in task 1 too). And, set lower and upper\n  bounds, as well as trigger_alert. To better understand this see the expected\n  change in the next slide\n*/\n\n\nexport class DataManipulator {\n  static generateRow(serverResponds: ServerRespond[]): Row {\n        const priceABC = (serverResponds[0].top_ask.price + serverResponds[0].top_bid.price)/2;\n        const priceDEF = (serverResponds[1].top_ask.price + serverResponds[1].top_bid.price)/2;\n        const ratio = priceABC / priceDEF;\n        const upper_bound = 1 + 0.07;\n        const lower_bound = 1 - 0.07;\n        return {\n          price_abc: priceABC,\n          price_def: priceDEF,\n          ratio,\n          timestamp: serverResponds[0].timestamp > serverResponds[1].timestamp ? \n            serverResponds[0].timestamp : serverResponds[1].timestamp,\n          upper_bound: upper_bound,\n          lower_bound: lower_bound,\n          trigger_alert: (ratio > upper_bound || ratio < lower_bound ) ? ratio : undefined,\n      };\n    }\n}\n\n\n/*\n● Observe how we’re able to access serverRespond as an array where in the\n  first element (0-index) is about stock ABC and the second element (1-index) is\n  about stock DEF. With this, we were able to easily just plug in values to the\n  formulas we used back in task 1 to compute for prices and ratio properly\n● Also note how the return value is changed from an array of Row objects to just\n  a single Row object This change explains why we also adjusted the argument\n  we passed to table.update in Graph.tsx earlier so that consistency is\n  preserved.\n● The upper_bound and lower_bound are pretty much constant for any data\n  point. This is how we will be able to maintain them as steady upper and lower\n  lines in the graph. While 1.05 and 0.95 isn’t really +/-10% of the 12 month\n  historical average ratio (i.e. 1.1 and 0.99) you’re free to play around with the\n  values and see which has a more conservative alerting behavior.\n● The trigger_alert field is pretty much just a field that has a value (e.g. the ratio)\n  if the threshold is passed by the ratio. Otherwise if the ratio remains within the\n  threshold, then no value/undefined will suffice.\n*/\n"]},"metadata":{},"sourceType":"module"}